<html>
    <head>
    <title>Pull Stream - Documentation - SSBC</title>
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="/styles.css">
    <link rel="stylesheet" href="/atelier-forest-light.css">
    <script src="/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
    <body>
      <div id="topnav">
    <div id="topnav-inner">
      <a class="topnav-item " href="/" title="Home">
      Home<br><small>SSBC</small>
    </a>
      <a class="topnav-item " href="/patchwork" title="Patchwork">
      Patchwork<br><small>Social Messaging App</small>
    </a>
      <a class="topnav-item " href="https://handbook.scuttlebutt.nz/guides/ssb-server/install" title="Scuttlebot">
      Scuttlebot<br><small>P2P Log Store</small>
    </a>
      <a class="topnav-item selected" href="/docs" title="Documentation">
      Documentation<br><small>APIs, Articles</small>
    </a>
    </div>
  </div>
      <div id="layout">
        <div id="leftnav">
      <div class="leftnav-item">Key Concepts</div>
      <div class="leftnav-subitems">
        <div class="leftnav-item ">
      <a href="/scuttlebutt-protocol-guide" title="Secure Scuttlebutt: a global database protocol">Secure Scuttlebutt: a global database protocol</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/ssb/linking.html" title="Content-Hash Linking">Content-Hash Linking</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/ssb/secret-handshake.html" title="Secret Handshake: a secure channel protocol">Secret Handshake: a secure channel protocol</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/ssb/end-to-end-encryption.html" title="Private Box: metadata-free encryption">Private Box: metadata-free encryption</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/ssb/faq.html" title="Frequently Asked Questions">Frequently Asked Questions</a>
    </div>
      </div>
      <div class="leftnav-item">API Documentation</div>
      <div class="leftnav-subitems">
        <div class="leftnav-item ">
      <a href="https://github.com/ssbc/ssb-server" title="scuttlebot">scuttlebot</a>
    </div>
        <div class="leftnav-indent">
          <div class="leftnav-item ">
      <a href="https://scuttlebot.io/apis/scuttlebot/blobs.html" title="blobs">blobs</a>
    </div>
          <div class="leftnav-item ">
      <a href="https://github.com/ssbc/ssb-friends" title="friends">friends</a>
    </div>
          <div class="leftnav-item ">
      <a href="https://github.com/ssbc/ssb-gossip" title="gossip">gossip</a>
    </div>
          <div class="leftnav-item ">
      <a href="https://github.com/ssbc/ssb-invite" title="invite">invite</a>
    </div>
          <div class="leftnav-item ">
      <a href="https://github.com/ssbc/ssb-private" title="private">private</a>
    </div>
          <div class="leftnav-item ">
      <a href="https://github.com/ssbc/ssb-replicate" title="replicate">replicate</a>
    </div>
        </div>
        <div class="leftnav-item ">
      <a href="/ssb-client" title="ssb-client">ssb-client</a>
    </div>
        <div class="leftnav-item ">
      <a href="/ssb-feed" title="ssb-feed">ssb-feed</a>
    </div>
        <div class="leftnav-item ">
      <a href="/ssb-keys" title="ssb-keys">ssb-keys</a>
    </div>
        <div class="leftnav-item ">
      <a href="/ssb-msgs" title="ssb-msgs">ssb-msgs</a>
    </div>
        <div class="leftnav-item ">
      <a href="/ssb-msg-schemas" title="ssb-msg-schemas">ssb-msg-schemas</a>
    </div>
        <div class="leftnav-item ">
      <a href="/ssb-ref" title="ssb-ref">ssb-ref</a>
    </div>
        <div class="leftnav-item ">
      <a href="/ssb-markdown" title="ssb-markdown">ssb-markdown</a>
    </div>
        <div class="leftnav-item ">
      <a href="/patchwork-threads" title="patchwork-threads">patchwork-threads</a>
    </div>
        <div class="leftnav-item ">
      <a href="/ssb-config" title="ssb-config">ssb-config</a>
    </div>
        <div class="leftnav-item ">
      <a href="/secret-stack" title="secret-stack">secret-stack</a>
    </div>
        <div class="leftnav-item ">
      <a href="/muxrpc" title="muxrpc">muxrpc</a>
    </div>
        <div class="leftnav-item ">
      <a href="/muxrpcli" title="muxrpcli">muxrpcli</a>
    </div>
        <div class="leftnav-item ">
      <a href="/mdmanifest" title="mdmanifest">mdmanifest</a>
    </div>
        <div class="leftnav-item selected">
      <a href="/docs/api/pull-stream.html" title="pull-stream">pull-stream</a>
    </div>
      </div>
    </div>
        <div id="content">
          <h1 id="pull-stream">pull-stream</h1>
<p>Minimal Pipeable Pull-stream</p>
<p>In <a href="https://github.com/nodejs/node-v0.x-archive/blob/v0.8/doc/api/stream.markdown">classic-streams</a>,
streams <em>push</em> data to the next stream in the pipeline.
In <a href="https://github.com/nodejs/node-v0.x-archive/blob/v0.10/doc/api/stream.markdown">new-streams</a>,
data is pulled out of the source stream, into the destination.
<code>pull-stream</code> is a minimal take on streams,
pull streams work great for &quot;object&quot; streams as well as streams of raw text or binary data.</p>
<p><a href="https://travis-ci.org/pull-stream/pull-stream"><img src="https://secure.travis-ci.org/pull-stream/pull-stream.png" alt="build status"></a></p>
<h2 id="quick-example">Quick Example</h2>
<p>Stat some files:</p>
<pre><code class="lang-js">pull(
  pull.values([&#39;file1&#39;, &#39;file2&#39;, &#39;file3&#39;]),
  pull.asyncMap(fs.stat),
  pull.collect(function (err, array) {
    console.log(array)
  })
)
</code></pre>
<p>Note that <code>pull(a, b, c)</code> is basically the same as <code>a.pipe(b).pipe(c)</code>.</p>
<p>To grok how pull-streams work, read through <a href="https://github.com/pull-stream/pull-stream-workshop">pull-streams workshop</a></p>
<h2 id="how-do-i-do-x-with-pull-streams-">How do I do X with pull-streams?</h2>
<p>There is a module for that!</p>
<p>Check the <a href="https://github.com/pull-stream/pull-stream-faq">pull-stream FAQ</a>
and post an issue if you have a question that is not covered.</p>
<h2 id="compatibily-with-node-streams">Compatibily with node streams</h2>
<p>pull-streams are not <em>directly</em> compatible with node streams,
but pull-streams can be converted into node streams with
<a href="https://github.com/pull-stream/pull-stream-to-stream">pull-stream-to-stream</a>
and node streams can be converted into pull-stream using <a href="https://github.com/pull-stream/stream-to-pull-stream">stream-to-pull-stream</a>
correct back pressure is preserved.</p>
<h3 id="readable-reader-vs-readable-writable">Readable &amp; Reader vs. Readable &amp; Writable</h3>
<p>Instead of a readable stream, and a writable stream, there is a <code>readable</code> stream,
 (aka &quot;Source&quot;) and a <code>reader</code> stream (aka &quot;Sink&quot;). Through streams
is a Sink that returns a Source.</p>
<p>See also:</p>
<ul>
<li><a href="./docs/sources/index.md">Sources</a></li>
<li><a href="./docs/throughs/index.md">Throughs</a></li>
<li><a href="./docs/sinks/index.md">Sinks</a></li>
</ul>
<h3 id="source-readable-stream-that-produces-values-">Source (readable stream that produces values)</h3>
<p>A Source is a function <code>read(end, cb)</code>,
that may be called many times,
and will (asynchronously) call <code>cb(null, data)</code> once for each call.</p>
<p>To signify an end state, the stream eventually returns <code>cb(err)</code> or <code>cb(true)</code>.
When signifying an end state, <code>data</code> <em>must</em> be ignored.</p>
<p>The <code>read</code> function <em>must not</em> be called until the previous call has called back.
Unless, it is a call to abort the stream (<code>read(Error || true, cb)</code>).</p>
<pre><code class="lang-js">var n = 5;

// random is a source 5 of random numbers.
function random (end, cb) {
  if(end) return cb(end)
  // only read n times, then stop.
  if(0 &gt; --n) return cb(true)
  cb(null, Math.random())
}

</code></pre>
<h3 id="sink-reader-or-writable-stream-that-consumes-values-">Sink (reader or writable stream that consumes values)</h3>
<p>A Sink is a function <code>reader(read)</code> that calls a Source (<code>read(null, cb)</code>),
until it decides to stop (by calling <code>read(true, cb)</code>), or the readable ends (<code>read</code> calls
<code>cb(Error || true)</code></p>
<p>All <a href="./docs/throughs/index.md">Throughs</a>
and <a href="./docs/sinks/index.md">Sinks</a>
are reader streams.</p>
<pre><code class="lang-js">// logger reads a source and logs it.
function logger (read) {
  read(null, function next(end, data) {
    if(end === true) return
    if(end) throw end

    console.log(data)
    read(null, next)
  })
}
</code></pre>
<p>Since Sources and Sinks are functions, you can pass them to each other!</p>
<pre><code class="lang-js">logger(random) //&quot;pipe&quot; the streams.

</code></pre>
<p>but, it&#39;s easier to read if you use&#39;s pull-stream&#39;s <code>pull</code> method</p>
<pre><code class="lang-js">var pull = require(&#39;pull-stream&#39;)

pull(random, logger)
</code></pre>
<h3 id="creating-reusable-streams">Creating reusable streams</h3>
<p>When working with pull streams it is common to create functions that return a stream.
This is because streams contain mutable state and so can only be used once. 
In the above example, once <code>random</code>  has been connected to a sink and has produced 5 random numbers it will not produce any more random numbers if connected to another sink.</p>
<p>Therefore, use a function like this to create a random number generating stream that can be reused:</p>
<pre><code class="lang-js">
// create a stream of n random numbers
function createRandomStream (n) {
  return function randomReadable (end, cb) {
    if(end) return cb(end)
    if(0 &gt; --n) return cb(true)
    cb(null, Math.random())
  }
}

pull(createRandomStream(5), logger)
</code></pre>
<h3 id="through">Through</h3>
<p>A through stream is both a reader (consumes values) and a readable (produces values).
It&#39;s a function that takes a <code>read</code> function (a Sink),
and returns another <code>read</code> function (a Source).</p>
<pre><code class="lang-js">// double is a through stream that doubles values.
function double (read) {
  return function readable (end, cb) {
    read(end, function (end, data) {
      cb(end, data != null ? data * 2 : null)
    })
  }
}

pull(createRandomStream(5), double, logger)
</code></pre>
<h3 id="pipeability">Pipeability</h3>
<p>Every pipeline must go from a <code>source</code> to a <code>sink</code>.
Data will not start moving until the whole thing is connected.</p>
<pre><code class="lang-js">pull(source, through, sink)
</code></pre>
<p>some times, it&#39;s simplest to describe a stream in terms of other streams.
pull can detect what sort of stream it starts with (by counting arguments)
and if you pull together through streams, it gives you a new through stream.</p>
<pre><code class="lang-js">var tripleThrough =
  pull(through1(), through2(), through3())
// The three through streams become one.

pull(source(), tripleThrough, sink())
</code></pre>
<p>pull detects if it&#39;s missing a Source by checking function arity,
if the function takes only one argument it&#39;s either a sink or a through.
Otherwise it&#39;s a Source.</p>
<h2 id="duplex-streams">Duplex Streams</h2>
<p>Duplex streams, which are used to communicate between two things,
(i.e. over a network) are a little different. In a duplex stream,
messages go both ways, so instead of a single function that represents the stream,
you need a pair of streams. <code>{source: sourceStream, sink: sinkStream}</code></p>
<p>pipe duplex streams like this:</p>
<pre><code class="lang-js">var a = duplex()
var b = duplex()

pull(a.source, b.sink)
pull(b.source, a.sink)

//which is the same as

b.sink(a.source); a.sink(b.source)

//but the easiest way is to allow pull to handle this

pull(a, b, a)

//&quot;pull from a to b and then back to a&quot;

</code></pre>
<h2 id="design-goals-rationale">Design Goals &amp; Rationale</h2>
<p>There is a deeper,
<a href="http://en.wikipedia.org/wiki/Platonic_idealism">platonic abstraction</a>,
where a streams is just an array in time, instead of in space.
And all the various streaming &quot;abstractions&quot; are just crude implementations
of this abstract idea.</p>
<p><a href="https://github.com/joyent/node/blob/v0.8.16/doc/api/stream.markdown">classic-streams</a>,
<a href="https://github.com/joyent/node/blob/v0.10/doc/api/stream.markdown">new-streams</a>,
<a href="https://github.com/Gozala/reducers">reducers</a></p>
<p>The objective here is to find a simple realization of the best features of the above.</p>
<h3 id="type-agnostic">Type Agnostic</h3>
<p>A stream abstraction should be able to handle both streams of text and streams
of objects.</p>
<h3 id="a-pipeline-is-also-a-stream-">A pipeline is also a stream.</h3>
<p>Something like this should work: <code>a.pipe(x.pipe(y).pipe(z)).pipe(b)</code>
this makes it possible to write a custom stream simply by
combining a few available streams.</p>
<h3 id="propagate-end-error-conditions-">Propagate End/Error conditions.</h3>
<p>If a stream ends in an unexpected way (error),
then other streams in the pipeline should be notified.
(this is a problem in node streams - when an error occurs,
the stream is disconnected, and the user must handle that specially)</p>
<p>Also, the stream should be able to be ended from either end.</p>
<h3 id="transparent-backpressure-laziness">Transparent Backpressure &amp; Laziness</h3>
<p>Very simple transform streams must be able to transfer back pressure
instantly.</p>
<p>This is a problem in node streams, pause is only transfered on write, so
on a long chain (<code>a.pipe(b).pipe(c)</code>), if <code>c</code> pauses, <code>b</code> will have to write to it
to pause, and then <code>a</code> will have to write to <code>b</code> to pause.
If <code>b</code> only transforms <code>a</code>&#39;s output, then <code>a</code> will have to write to <code>b</code> twice to
find out that <code>c</code> is paused.</p>
<p><a href="https://github.com/Gozala/reducers">reducers</a> reducers has an interesting method,
where synchronous tranformations propagate back pressure instantly!</p>
<p>This means you can have two &quot;smart&quot; streams doing io at the ends, and lots of dumb
streams in the middle, and back pressure will work perfectly, as if the dumb streams
are not there.</p>
<p>This makes laziness work right.</p>
<h3 id="handling-end-error-and-abort-">handling end, error, and abort.</h3>
<p>in pull streams, any part of the stream (source, sink, or through)
may terminate the stream. (this is the case with node streams too,
but it&#39;s not handled well).</p>
<h4 id="source-end-error">source: end, error</h4>
<p>A source may end (<code>cb(true)</code> after read) or error (<code>cb(error)</code> after read)
After ending, the source <em>must</em> never <code>cb(null, data)</code></p>
<h4 id="sink-abort">sink: abort</h4>
<p>Sinks do not normally end the stream, but if they decide they do
not need any more data they may &quot;abort&quot; the source by calling <code>read(true, cb)</code>.
A abort (<code>read(true, cb)</code>) may be called before a preceding read call
has called back.</p>
<h3 id="handling-end-abort-error-in-through-streams">handling end/abort/error in through streams</h3>
<p>Rules for implementing <code>read</code> in a through stream:
1) Sink wants to stop. sink aborts the through</p>
<pre><code>just forward the exact read() call to your source,
any future read calls should cb(true).
</code></pre><p>2) We want to stop. (abort from the middle of the stream)</p>
<pre><code>abort your source, and then cb(true) to tell the sink we have ended.
If the source errored during abort, end the sink by cb read with `cb(err)`.
(this will be an ordinary end/error for the sink)
</code></pre><p>3) Source wants to stop. (<code>read(null, cb) -&gt; cb(err||true)</code>)</p>
<pre><code>forward that exact callback towards the sink chain,
we must respond to any future read calls with `cb(err||true)`.
</code></pre><p>In none of the above cases data is flowing!
4) If data is flowing (normal operation:   <code>read(null, cb) -&gt; cb(null, data)</code></p>
<pre><code>forward data downstream (towards the Sink)
do none of the above!
</code></pre><p>There either is data flowing (4) OR you have the error/abort cases (1-3), never both.</p>
<h2 id="1-1-read-callback-ratio">1:1 read-callback ratio</h2>
<p>A pull stream source (and thus transform) returns <em>exactly one value</em> per read.</p>
<p>This differs from node streams, which can use <code>this.push(value)</code> and in internal
buffer to create transforms that write many values from a single read value.</p>
<p>Pull streams don&#39;t come with their own buffering mechanism, but <a href="https://github.com/dominictarr/pull-stream-examples/blob/master/buffering.js">there are ways
to get around this</a>.</p>
<h2 id="minimal-bundle">Minimal bundle</h2>
<p>If you need only the <code>pull</code> function from this package you can reduce the size
of the imported code (for instance to reduce a Browserify bundle) by requiring
it directly:</p>
<pre><code class="lang-js">var pull = require(&#39;pull-stream/pull&#39;)

pull(createRandomStream(5), logger())
</code></pre>
<h2 id="further-examples">Further Examples</h2>
<ul>
<li><a href="https://github.com/dominictarr/pull-stream-examples">dominictarr/pull-stream-examples</a></li>
<li><a href="./docs/examples.md">./docs/examples</a></li>
</ul>
<p>Explore this repo further for more information about
<a href="./docs/sources/index.md">sources</a>,
<a href="./docs/throughs/index.md">throughs</a>,
<a href="./docs/sinks/index.md">sinks</a>, and
<a href="./docs/glossary.md">glossary</a>.</p>
<h2 id="license">License</h2>
<p>MIT</p>

        </div>
      </div>
    </body>
  </html>